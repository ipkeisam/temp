AWSTemplateFormatVersion: 2010-09-09
Description: Deploy resources (in Master account) for autotagging Datapipeline automation
Resources:
  DataPipelineEventRule:
    Type: AWS::Events::Rule
    Properties: 
      Description: Rule created to trigger a lambda function each time a resource is created
      EventPattern: 
        source:
        - aws.datapipeline
        detail-type:
        - AWS API Call via CloudTrail
        detail:
          eventSource:
          - datapipeline.amazonaws.com
          eventName:
          - CreatePipeline
          
      EventBusName: tagging
      Name: AutoTag-DataPipeline-Event
      State: ENABLED
      Targets: 
        - 
          Arn: 
            Fn::GetAtt:
            - LFAutotagDataPipeline
            - Arn
          Id: LFAutotagDataPipelineProduction
  LFAutotagDataPipelineRole:
    Type: AWS::IAM::Role
    Properties:
      Description: Role to create DataPipeline resources
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: 
                - lambda.amazonaws.com
            Action: sts:AssumeRole
      Policies:
        - PolicyName: LFAutotagDataPipelinePolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - "datapipeline:PutPipelineDefinition"
                  - "datapipeline:ListPipelines"
                  - "datapipeline:QueryObjects"
                  - "datapipeline:GetPipelineDefinition"
                  - "datapipeline:AddTags"
                  - "logs:CreateLogGroup"
                  - "logs:CreateLogStream"
                  - "logs:PutLogEvents"
                  - "organizations:ListTagsForResource"
                Resource: "*"
              - Sid: AssumeOrgRole
                Effect: Allow
                Action: 'sts:AssumeRole'
                Resource: 'arn:aws:iam::*:role/OrganizationAccountAccessRole'
  LFAutotagDataPiplineLG:
    Type: AWS::Logs::LogGroup
    DependsOn: LFAutotagDataPipeline
    DeletionPolicy: Retain
    Properties:
      LogGroupName:
        Fn::Join:
          - ''
          - - /aws/lambda/
            - Ref: LFAutotagDataPipeline
      RetentionInDays: 14
  CWToLFDataPipelinePermission:
    Type: AWS::Lambda::Permission
    Properties:
      Action: lambda:InvokeFunction
      Principal: events.amazonaws.com
      FunctionName:
        Fn::GetAtt:
          - LFAutotagDataPipeline
          - Arn
      SourceArn:
        Fn::GetAtt:
          - DataPipelineEventRule
          - Arn
  LFAutotagDataPipeline:
    Type: AWS::Lambda::Function
    Properties:
      Description: Function to tag Datapipeline resource in response to CloudWatch Events
      Handler: index.lambda_handler
      Role: 
        Fn::GetAtt: 
          - LFAutotagDataPipelineRole
          - Arn
      Runtime: python3.7
      Timeout: '60'
      Code:
        ZipFile: |
            from __future__ import print_function
            import json
            import os
            import boto3
            import logging
            import time
            import datetime

            logger = logging.getLogger()
            logger.setLevel(logging.INFO)

            def data_pipeline_tags(credentials,pipeline_id,account_id):
              old_tags = {}
              old_tags1 = {}
              mandatory_tags1 = {}
              new_tags = {}
              session = boto3.session.Session()
              client=boto3.client(
                      service_name='datapipeline',
                      aws_access_key_id=credentials['AccessKeyId'],
                      aws_secret_access_key=credentials['SecretAccessKey'],
                      aws_session_token=credentials['SessionToken']
                  )
              print("Tagging the Resource" + pipeline_id)
              acctags = boto3.client('organizations').list_tags_for_resource(ResourceId=account_id)['Tags']
              mandatory_tags = {i['Key']: i['Value'] for i in acctags}
              l1=['remediation-group','account-name','poc','auto-tag','account-type','sensitive-nonprod']
              for i,j in mandatory_tags.items():
                if i not in l1:
                  mandatory_tags1[str(i)]=str(j)
     
  
  
              try:
                p1=[pipeline_id]
                old_tags=client.describe_pipelines(pipelineIds=p1)
                for each in old_tags['pipelineDescriptionList']:
                  old_tags1=each['tags']
                old={i['key']:i['value'] for i in old_tags1}  
                print("oldtags" )
                print(old)
              except Exception as e:
                print(e)
              new_tags = {**mandatory_tags1,**old}
              print('Tagging resource ' + pipeline_id)
              print(new_tags)
              print(len(new_tags))

              try:
    
                if len(new_tags)<=10:
      
                  response=client.add_tags(pipelineId=pipeline_id,
                  tags=[
                        {'key': str(k), 'value': str(v)} for k, v in new_tags.items()
                    ]
                  )
                  print(response)
                  return True
                else:
                  print("exceeding tag values")
                  return False
      
              except Exception as e:
                print(e)
                return False

            def assume_role(account_id, account_role):
              sts_client = boto3.client('sts')
              role_arn = 'arn:aws:iam::' + account_id + ':role/' + account_role
              assuming_role = True
              while assuming_role is True:
                  try:
                    assuming_role = False
                    assumedRoleObject = sts_client.assume_role(
                    RoleArn=role_arn,
                    RoleSessionName="NewAccountRole"
                    )
                  except botocore.exceptions.ClientError as e:
                    assuming_role = True
                    print(e)
                    print("Retrying...")
                    time.sleep(60)

              # From the response that contains the assumed role, get the temporary
              # credentials that can be used to make subsequent API calls
              return assumedRoleObject['Credentials']

            def lambda_handler(event, context):
  
              try:
                print(event)
                region = event['region']
                detail = event['detail']
                account_id=event['account']
                eventname = detail['eventName']

                #logger.info('region: ' + str(region))
                logger.info('eventName: ' + str(eventname))
                logger.info('detail: ' + str(detail))

                if account_id == '848721808596':
                  return False

                if eventname == 'CreatePipeline':
                  pipeline_id = detail['responseElements']['pipelineId']
                  print(pipeline_id)
                  logger.info(pipeline_id)

                #Assume role of member account before tagging datapipeline resource
                account_role = 'OrganizationAccountAccessRole'
                credentials = assume_role(account_id, account_role)

                if pipeline_id:
                  response =  data_pipeline_tags(credentials,pipeline_id,account_id)
                  return response
                else:
                  return false


              except Exception as e:
                logger.error('Something went wrong: ' + str(e))
                return False
